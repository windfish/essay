## java 内存区域

### 运行时数据区域

![](https://oscimg.oschina.net/oscnet/up-a4f8299e9df48942fbc1bd6ec704ce9da0d.png)

##### 程序计数器
* 一块较小的内存空间，看作是当前线程所执行的字节码的行号指示器。
* Java 多线程是通过线程轮流切换并分配处理器执行时间来实现的，因此，每条线程都有独立的程序计数器，是线程私有的内存。
* 若线程在执行一个java 方法，则计数器记录的是字节码指令的地址；若是本地Native 方法，则计数器为空。
* 此区域是唯一一个在java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域

##### Java 虚拟机栈
* 线程私有的，它的生命周期与线程相同
* 虚拟机栈描述的是Java 方法执行的内存模型：
    * 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息
    * 每个方法从调用直到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程
* 通常说的堆内存Heap 和栈内存Stack，栈指的就是虚拟机栈中的局部变量表
* 局部变量表存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 对象）、returnAddress 类型（指向了一条字节码指令的地址）
* 局部变量表所需的内存空间在编译期间完成分配，一个方法在栈帧中分配多大的局部变量空间是完全确定的
    * 64位长度的long 和double 类型的数据占用两个局部变量空间（Slot）
    * 其他数据类型占用一个Slot
* 该区域规定了两种异常状态：
    * 如果线程请求的栈深度大于虚拟机所允许的深度，抛出 StackOverflowError 异常
    * 如果虚拟机栈无法申请到足够的内存，抛出 OutOfMemoryError 异常

##### 本地方法栈
* 本地方法栈与虚拟机栈相似，只不过为虚拟机使用到的Native 方法服务
* HotSpot 虚拟机将本地方法栈和虚拟机栈合二为一
* 也会抛出StackOverflowError 和 OutOfMemoryError 异常

##### Java 堆
* 内存中最大的一块，并且是被所有线程共享的一块内存区域，在虚拟机启动时创建
* 存放几乎所有的对象实例，JIT 编译器与逃逸分析技术的发展，栈上分配、标量替换让所有对象都在堆上分配变得不那么绝对了
* 是垃圾收集器管理的主要区域
* 一般是可扩展的，通过-Xms 和-Xmx 控制，无法再扩展时，抛出 OutOfMemoryError 异常

##### 方法区
* 线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据
* 无法满足内存需求时，抛出 OutOfMemoryError 异常

##### 运行时常量池
* 是方法区的一部分，Class 文件有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，在类加载后进入运行时常量池
* 运行时常量池相对于Class 文件常量池是具备动态性，允许运行期间将新的常量放入池中，例如 String 的intern() 方法
* 也会抛出 OutOfMemoryError 异常

##### 直接内存
* 并不是虚拟机运行时的数据区的一部分，也不是规范中定义的内存区域
* 它使用Native 函数库直接分配堆外内存，通过存储在堆中的DirectByteBuffer 对象作为这块内存的引用，避免了在Java 堆和Native 堆中来回复制数据
* 不受Java 堆大小的限制，受本机总内存大小以及处理器寻址空间的限制
* 也会抛出 OutOfMemoryError 异常


### 虚拟机对象

##### 创建对象

![](https://oscimg.oschina.net/oscnet/up-f2c422c3e896da4bf478e9e9debe4252e36.png)

内存分配的方式：
* 指针碰撞 Bump the Pointer
    * 若Java 堆内存是绝对规整的，用过的内存在一边，空闲的内存在另一边，中间放着指针作为分界点的指示器
    * 分配内存仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为 指针碰撞
* 空闲列表 Free List
    * 若Java 内存并不是规整的，已使用的内存和空闲的内存相互交错
    * 需要维护一个列表，记录哪块内存是可用的，在分配的时候从列表中找一块足够大的空间划分给对象实例，并更新列表上的记录

内存分配可能存在线程安全问题，解决方案：
* 对分配内存空间的操作进行同步处理，虚拟机采用CAS 配上失败重试的方式保证更新操作的原子性
* 把内存分配的动作按照线程划分在不同的空间之中进行
    * 每个Java 线程先预先分配一小块内存，称为本地线程分配缓冲TLAB
    * 分配内存时，先在线程的TLAB 上分配，TLAB 用完并分配新的TLAB 时才需要同步锁定
    * -XX:+/-UseTLAB 参数来设定是否启用


##### 对象的内存布局

* 对象头 Header
    * Mark Word
        * 存储对象自身的运行数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
        * 32位虚拟机的数据长度为32bit；64位虚拟机的数据长度为64bit，若开启指针压缩，将节约50%的内存，+UseCompressedOops 用来开启指针压缩
        * 32bit 的空间，25bit 存储对象哈希码，4bit 存储对象分代年龄，2bit 存储锁标志位，1bit 固定为0
        ```
        |-------------------------------------------------------|--------------------|
        |                  Mark Word (32 bits)                  |       State        |
        |-------------------------------------------------------|--------------------|
        | identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |
        |-------------------------------------------------------|--------------------|
        |  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |
        |-------------------------------------------------------|--------------------|
        |               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |
        |-------------------------------------------------------|--------------------|
        |               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |
        |-------------------------------------------------------|--------------------|
        |                                              | lock:2 |    Marked for GC   |
        |-------------------------------------------------------|--------------------|
        ```
    * 类型指针，即对象指向它的类元数据的指针，通过这个指针来确定对象是哪个类的实例
    * 若对象是Java 数组，则还需有一块记录数组长度的数据
* 实例数据 Instance Data
    * 存储对象真正的有效信息，包括父类继承下来的
* 对齐填充 Padding
    * 并不是必然存在的，仅仅起占位符的作用，HotSpot 要求对象的大小必须是8的倍数，需要通过对齐来补全


##### 对象的访问定位
通过栈上的reference 数据来操作堆上的具体对象，有两种对象访问方式：
* 使用句柄访问，reference 存储的是对象的句柄地址，堆中会划分一块内存作为句柄池，句柄包含了对象的实例数据与类型数据的地址信息
* 使用直接指针访问，reference 存储的是对象地址，HotSpot 使用的这种方式


## 垃圾收集器与内存分配策略

### 判断对象已死

##### 引用计数算法

基本思想是，给对象添加一个引用计数器，每当有一个地方引用它，计数器加1；引用失效时，计数器减1；计数器为0的对象就是不再被使用的

担忧一个问题，很难解决对象之间循环引用的问题。
例如：对象A 和对象B 都有字段instance，并互相引用对方的实例，除此之外，再无其他引用，这会导致两个对象的引用计数器都不为0

##### 可达性分析算法

基本思想是，通过一系列称为"GC roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径为引用链，当一个对象到GC roots 没有任何引用链时，证明此对象不可用

在Java 中，GC roots 对象包含：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI 引用的对象

##### 对象引用
* 强引用 Strong Reference：
    * 代码中普遍存在的，例如 Object obj = new Object()，只要强引用还存在，GC 就不会回收掉被引用的对象
* 软引用 Soft Reference：
    * 用来描述一些还有用但并非必须的对象，对于软引用的对象，在内存发生溢出之前，会被回收
* 弱引用 Weak Reference：
    * 用来描述非必须对象的，但强度比软引用弱，对于软引用的对象，只能存活到下一次GC 之前
    * 当GC 时，不论内存是否足够，该对象都会被回收
* 虚引用 Phantom Reference：
    * 是最弱的一种引用关系，对于虚引用的对象，不会影响其生存时间，也无法通过虚引用来获取一个对象实例
    * 虚引用关联的唯一目的是能在这个对象被GC 时收到一个系统通知

##### 回收方法区
* 一般不需要回收，而且在方法区中进行GC 的性价比比较低。
* 主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收堆中的对象类似
* 判断无用的类就比较苛刻，需满足三个条件：
    * 该类所有的实例都已被回收
    * 加载该类的ClassLoader 已被回收
    * 该类对应的java.lang.Class 对象没有在任何地方被引用，无法通过反射访问该类的方法
* 是否对类进行回收，使用 -Xnoclassgc 参数进行控制

### 垃圾收集算法

##### 标记-清除算法 Mark-Sweep
最基础的收集算法，分为标记和清除两个阶段：首先标记所有需要回收的对象，然后统一回收所有被标记的对象

*不足*
* 一是效率问题，标记和清除两个过程效率都不高；
* 二是空间问题，清除之后会有大量不连续的内存碎片，碎片太多可能会导致以后分配较大对象时，没有足够的连续内存分配而不得不提前触发一次GC

##### 复制算法
将内存按容量划分为大小相等的两块，每次只使用其中一块。当一块内存用完了，就将存活的对象复制到另一块上，再把已使用的内存空间一次性清除。

这样每次都对半区进行内存回收，内存分配是也不用考虑碎片的问题，只需要复制时在堆顶按顺序分配即可。代价就是内存缩小为原来的一半。

**一般使用这种收集算法回收新生代**，因为新生代的对象98%都是朝生夕死的，内存分配可以不按照 1：1 的比例划分，
将内存分为一块较大的Eden 空间和两块较小的Survivor 空间，每次使用Eden 和一块Survivor。
当回收时，将Eden 和Survivor 中还存活的对象一次性地复制到另一块Survivor 上，然后清理掉Eden 和刚才用过的Survivor 空间。
HotSpot 默认Eden 和Survivor 的比例是 8：1

当另一块Survivor 空间不足时，这些对象能够通过担保机制进入老年代

##### 标记-整理算法 Mark-Compact
**老年代一般使用这种算法**，先标记所有需要回收的对象，然后让存活对象向一端移动，然后直接清理掉端边界以外的对象


### 垃圾收集器


















